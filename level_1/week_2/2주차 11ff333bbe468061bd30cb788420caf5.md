# 2주차

- 회고
    - 전체적으로 기억이 잘 안났다.
        - 문제를 풀때는 문제 푸는게 재밌어서 일단 성공하면 정리하기보다, 다음문제를 너무 풀고싶어진다.
        - 문제 많이 푸는게 목표가 아닌만큼, 한 문제를 풀고나서, 바로바로 정리해야할 듯 싶다.
        - 정리할 때 템플릿 같은게 있으면 좋을 것 같다.
        - 예를 들어 어떤식으로 문제를 이해했는지,
        - 그래서 어떤 풀이를 도입했는데
        - 실패했다면 어떤 부분에서 실패했는지
            - ex) 어떤 케이스에서 실패했는지
        - 문제의 양이 아니라 밀도를 높였을때 성장할 수 있을 것 같다.
        - 양은 그냥 현재 얼마나 들수 있는가 이고
        - 밀도는 성장할 수 있는가 이다.
    - 간단한 구현같은 경우 공유할 내용은 없지 않나 싶다.
    - 소수 만들기나 순열에 대한 접근은 스스로 고민해서 풀었다면 이후에 풀의가 잘 생각이 났다.
    - 문자열 파싱할 때, 간결성 및 직관성을 위해 regex문법은 거의 필수이다.
        - 뿐만아니라 실제 현업에서도 터미널이나 직렬화된 데이터를 파싱할 때 regex는 빠지지 않는다.
        - 우리에겐 ai가 있지만, 강의를 통해 기본적인 지식을 올려놓는게 좋을 수 도 있지 않을까?
        - https://www.inflearn.com/course/실무-정규식
    
- 템플릿 구성 (by. claude)
    
    ```markdown
    # 확장된 알고리즘 문제 풀이 정리
    
    ## 문제 정보
    - 문제 이름: 
    - 난이도: 
    - 링크: 
    - 관련 주제/태그: 
    
    ## 문제 이해
    Q1: 문제를 어떻게 해석했나요? 핵심 요구사항은 무엇인가요?
    A1: 
    
    Q2: 주어진 제약 조건은 무엇인가요?
    A2: 
    
    ## 문제 시각화
    Q3: 이 문제를 어떻게 시각화할 수 있을까요? (필요시 다이어그램 첨부)
    A3: 
    
    ## 접근 방법
    Q4: 어떤 알고리즘이나 자료구조를 떠올렸나요? 왜 그렇게 생각했나요?
    A4: 
    
    Q5: 처음에 떠올린 해결 방법은 무엇인가요?
    A5: 
    
    ## 의사코드 작성
    Q6: 해결 방법에 대한 의사코드를 작성해보세요.
    A6:
    ```
    // 의사코드를 이곳에 작성하세요
    ```
    
    ## 구현
    Q7: 어떤 언어로 구현했나요? 주요 코드를 작성해주세요.
    A7: 
    ```
    // 코드를 이곳에 작성하세요
    ```
    
    ## 복잡도 분석
    Q8: 구현한 솔루션의 시간 복잡도와 공간 복잡도는 어떻게 되나요? 어떻게 계산했나요?
    A8: 
    
    ## 테스트 케이스
    Q9: 어떤 테스트 케이스를 만들어 검증해 보았나요?
    A9: 
    
    ## 결과
    Q10: 첫 번째 시도에 성공했나요? 실패했다면 어떤 부분에서 문제가 있었나요?
    A10: 
    
    Q11: 예외 케이스는 무엇이었나요? 왜 이를 처음에 생각하지 못했나요?
    A11: 
    
    ## 최적화
    Q12: 초기 솔루션에서 어떤 최적화를 수행했나요?
    A12: 
    
    ## 다른 접근 방식
    Q13: 이 문제를 해결할 수 있는 다른 방법이 있을까요? 있다면 어떤 장단점이 있나요?
    A13: 
    
    ## 개선 및 학습
    Q14: 다른 사람의 풀이 중 인상적이었던 방식이 있었나요? 어떤 점에서 그랬나요?
    A14: 
    
    Q15: 이 문제를 통해 새롭게 알게된 점이나 복습한 개념이 있나요?
    A15: 
    
    Q16: 다음에 비슷한 문제를 만난다면 어떻게 접근할 것 같나요?
    A16: 
    
    ## 총평
    Q17: 이 문제의 핵심 포인트는 무엇이었다고 생각하나요?
    A17: 
    
    Q18: 이 문제를 풀면서 느낀 점이나 배운 점은 무엇인가요?
    A18: 
    
    ## 관련 문제
    Q19: 이 문제와 유사하거나 관련된 다른 문제들이 있나요?
    A19: 
    
    ## 추가 학습 사항
    Q20: 이 문제를 통해 더 공부하고 싶어진 주제나 개념이 있나요?
    A20:
    ```
    
- 정리
    
    ```markdown
    ## 문제 정보
    - 문제 이름: 
    - 난이도: 
    - 관련 주제/태그: 
    
    ## 문제 이해
    Q1: 문제의 핵심 요구사항과 제약 조건은 무엇인가요?
    A1:
    
    ## 접근 방법
    Q2: 어떤 알고리즘이나 자료구조를 사용했나요? 왜 그 방법을 선택했나요?
    A2:
    
    ## 어려웠던 점
    Q3: 문제 해결 과정에서 가장 어려웠던 부분은 무엇이었나요?
    A3:
    
    ## 최적화
    Q4: 초기 솔루션에서 어떤 최적화를 수행했나요?
    A4:
    
    ## 학습 포인트
    Q5: 이 문제를 통해 새롭게 알게 된 점이나 복습한 개념은 무엇인가요?
    A5:
    
    ## 다음 단계
    Q6: 이 문제와 관련하여 더 공부하고 싶은 주제가 있나요?
    A6:
    ```
    
- (저만이라도 편하게 쓸려고 [홈](https://www.notion.so/119f333bbe46801b9768d03793a1d8ab?pvs=21)에 추가해놓았습니다.)

## 1. [같은 숫자는 싫어](https://school.programmers.co.kr/learn/courses/30/lessons/12906)

```jsx
function solution(arr) {
  return arr.filter((a, i) => {
    if (i === 0) return true;
    if (a === arr[i - 1]) return false;
    return true;
  });
}
```

- 정리
    
    ```markdown
    ## 문제 정보
    - 문제 이름: 
    - 난이도: 1
    - 관련 주제/태그: 
    
    ## 문제 이해
    Q1: 문제의 핵심 요구사항과 제약 조건은 무엇인가요?
    A1: 배열을 필터링하는것, 배열의 크기가 백만이하의 자연수라는점
    
    ## 접근 방법
    Q2: 어떤 알고리즘이나 자료구조를 사용했나요? 왜 그 방법을 선택했나요?
    A2: 단순히 필터만 이용, 그렇게 해도 충분히 풀 수 있어서
    
    ## 어려웠던 점
    Q3: 문제 해결 과정에서 가장 어려웠던 부분은 무엇이었나요?
    A3: 없었음
    
    ## 최적화
    Q4: 초기 솔루션에서 어떤 최적화를 수행했나요?
    A4: 특별히 최적화는 사용 X
    
    ## 학습 포인트
    Q5: 이 문제를 통해 새롭게 알게 된 점이나 복습한 개념은 무엇인가요?
    A5: 없었음
    
    ## 다음 단계
    Q6: 이 문제와 관련하여 더 공부하고 싶은 주제가 있나요?
    A6: 일단 없음
    ```
    

## 2. [예산](https://school.programmers.co.kr/learn/courses/30/lessons/12982)

2주차 문제들중 가장 많은 시간을 보낸 친구

예산만큼 삭감하는 형태를 떠올리지 못했고, 정렬 후 이진탐색을 통해 빠르게 값을 찾아야한다고 생각함

그러나 이진탐색을 직접 구현하는게 생각보다 어려웠고, 꼭 맞는 index를 어떻게 구현하느냐가 생각보다 어려웠음

처음 코드는 여러 테케에 대응하기위해 스파게티와 다름 없게 통과했고

두번째는 claud를 통해 깔끔한 이상적인 이진탐색 코드를 생성

인덱스를 어떻게 설정했는지가 제일 중요하고 짚고넘어가야한다.

- 처음 풀이
    
    ```jsx
    function solution(d, budget) {
      if (sum(d) === budget) return d.length;
      if (d.length === 1) {
        return d[0] <= budget ? 1 : 0;
      }
      if (d.reduce((a, c) => a + c, 0) <= budget) return d.length;
    
      const arr = d.sort((a, b) => a - b);
    
      const len = arr.length;
      let i = Math.floor(len / 2);
      let start = 0;
      let end = len;
    
      while (true) {
        const prevArr = arr.slice(0, i);
        const nextArr = arr.slice(0, i + 1);
    
        if (sum(prevArr) <= budget && budget <= sum(nextArr)) {
          if (sum(nextArr) === budget) i++;
          break;
        } else if (sum(prevArr) < budget) {
          start = i;
          i = Math.floor((end + i) / 2);
        } else {
          end = i;
          i = Math.floor((start + i) / 2);
        }
      }
      return i;
    }
    
    const sum = (arr) => {
      return arr.reduce((acc, cur) => acc + cur, 0);
    };
    
    ```
    
- 클로드를 통해 깔끔화..?
    
    ```jsx
    function solution(d, budget) {
      d.sort((a, b) => a - b);
    
      let left = 0;
      let right = d.length;
    
      while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        const sum = calculateSum(d, mid);
    
        if (sum <= budget) {
          left = mid + 1;
        } else {
          right = mid - 1;
        }
      }
      return right;
    }
    
    function calculateSum(arr, mid) {
      return arr.slice(0, mid).reduce((acc, cur) => acc + cur, 0);
    }
    
    ```
    
- 다른사람 풀이
    
    ```jsx
    function solution(d, budget) {
        return d.sort((a, b) => a - b).reduce((count, price) => {
            return count + ((budget -= price) >= 0);
        }, 0);
    }
    ```
    
- 정리
    
    ```markdown
    ## 문제 정보
    - 문제 이름: 
    - 난이도: 
    - 관련 주제/태그: 
    
    ## 문제 이해
    Q1: 문제의 핵심 요구사항과 제약 조건은 무엇인가요?
    A1: 배열과 예산안이 있으며, 예산안 안에서 최대한 많은 숫자를 소모해야한다.
    
    ## 접근 방법
    Q2: 어떤 알고리즘이나 자료구조를 사용했나요? 왜 그 방법을 선택했나요?
    A2: 정렬 후 이진탐색을 통해 최적의 인덱스 값을 찾으려했다.
    선택한 이유는 그냥 바로 떠올렸기 때문이다.
    하지만 다른 사람 풀이를 봤을때, 예산안을 삭감하는 형태로 진행했다면 더욱 간단했을 것 같다.
    
    ## 어려웠던 점
    Q3: 문제 해결 과정에서 가장 어려웠던 부분은 무엇이었나요?
    A3:
    
    ## 최적화
    Q4: 초기 솔루션에서 어떤 최적화를 수행했나요?
    A4: 만약 값이 아주 작게 여러 숫자가 들어있다고 한다면, 내 풀이가 복잡도 O(Log(N))만큼이고, 
    기존 풀이는 O(N)이므로 내 풀이가 더 좋을지..?
    
    클로드 답변
    ## 성능 비교
    
    ### 시간 복잡도:
    
    - 두 풀이 모두 정렬로 인해 O(n log n)의 시간 복잡도를 가짐
    - 풀이 1은 정렬 후 한 번의 순회로 끝나지만, 풀이 2는 로그 횟수만큼의 추가 순회가 있음
    - 입력의 크기가 작을 때는 풀이 1이 더 빠를 수 있음
    - 입력의 크기가 매우 클 때는 풀이 2가 더 효율적일 수 있음 (특히 budget이 작은 경우)
    
    공간 복잡도:
    
    - 풀이 1: O(1)의 추가 공간만 사용
    - 풀이 2: O(n)의 추가 공간 사용 (slice 연산으로 인해)
    
    ## 학습 포인트
    Q5: 이 문제를 통해 새롭게 알게 된 점이나 복습한 개념은 무엇인가요?
    A5: 제한된 자원을 이용해야한다면 점점 깎이는 형태의 문제풀이를 고민해볼 것
    
    ## 다음 단계
    Q6: 이 문제와 관련하여 더 공부하고 싶은 주제가 있나요?
    A6: 잘 모르겠음
    ```
    

## 3. [3진법 뒤집기](https://school.programmers.co.kr/learn/courses/30/lessons/68935)

```jsx
function solution(n) {
    let three = n.toString(3);
    let reverse = three.split('').reverse((a, b) => a-b).join('')
    return parseInt(reverse, 3)
}
```

이전에 작성한 풀이인데, number에 toString()은 처음 보는듯한 느낌

## 4. [크기가 작은 부분 문자열](https://school.programmers.co.kr/learn/courses/30/lessons/147355)

```jsx
function solution(t, p) {
  var answer = 0;

  const p_len = p.length;
  const t_len = t.length;

  for (let i = 0; i <= t_len - p_len; i++) {
    const t_subStr = t.substring(i, i + p_len);
    if (isBig(t_subStr, p)) answer++;
  }

  return answer;
}

function isBig(a, b) {
  return Number(a) <= Number(b);
}
```

쉬움, 다른 사람풀이에서도 크게 다르지 않음

## 5. [이상한 문자 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/12930)

각 단어의 짝수번째 알파벳은 대문자로, 

홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요.

```jsx
function solution(s) {
  return s
    .split(" ")
    .map((v) =>
      v
        .split("")
        .map((v, i) => {
          if (i % 2 === 0) return v.toUpperCase();
          return v.toLowerCase();
        })
        .join("")
    )
    .join(" ");
}

```

말 그대로함

물론 훨씬 깔끔하게도 있긴 했음

```jsx
function solution(s) {
  return s.toUpperCase().replace(/(\w)(\w)/g, function (a) {
    return a[0].toUpperCase() + a[1].toLowerCase();
  });
}
```

`/(\w)(\w)/g` 

- “a1b2c3” → “a1”, “b2”, “c3” 형태로 도출됨
- (\w) → 첫 번째 캡쳐 그룹, \w는 word문자를 나타냄, 알파벳(대소문자), 숫자, 언더스코어와 매치됨
    - 괄호 `()` 로 감싸져 있어 이 부분이 캡처됨
- `캡처` 란?
    - 매칭된 문자열의 일부를 따로 저장하여 나중에 참조할 수 있게 하는 기능
    - 주로 괄호를 사용하여 수행
    1. 그룹화
        - 괄호로 감싼 부분은 하나의 단위로 취급됨
        - 이를 통해 복잡한 패턴을 만들 수 있음
    2. 참조 가능
        1. 매칭 결과에서 캡처된 부분을 개별적으로 접근할 수 있음
        2. 많은 프로그래밍 언어에서 캡처된 그룹은 배열이나 객체의 형태로 제공됨
    3. 치환에서의 사용
        1. 문자열 치환 시 캡처된 그룹을 참조하여 사용할 수 있음
    4. 정규식 내에서의 재사용
        1. 정규식 내에서 ‘\1’, ‘\2’ 등으로 이전에 캡처된 그룹을 재사용할 수 있음

빈 문자열은 인식 안하니까 초반에 UpperCase때린게 .. 뭔가 아직 쉽게 나오진 않겠다 싶음

- 알고리즘 정리 양식
    
    ```markdown
    ## 문제 정보
    - 문제 이름: 
    - 난이도: 
    - 관련 주제/태그: 
    
    ## 문제 이해
    Q1: 문제의 핵심 요구사항과 제약 조건은 무엇인가요?
    A1: 
    
    ## 접근 방법
    Q2: 어떤 알고리즘이나 자료구조를 사용했나요? 왜 그 방법을 선택했나요?
    A2:
    
    ## 어려웠던 점
    Q3: 문제 해결 과정에서 가장 어려웠던 부분은 무엇이었나요?
    A3:
    
    ## 최적화
    Q4: 초기 솔루션에서 어떤 최적화를 수행했나요?
    A4:
    
    ## 학습 포인트
    Q5: 이 문제를 통해 새롭게 알게 된 점이나 복습한 개념은 무엇인가요?
    A5:
    
    ## 다음 단계
    Q6: 이 문제와 관련하여 더 공부하고 싶은 주제가 있나요?
    A6:
    ```
    

## 6. [삼총사](https://school.programmers.co.kr/learn/courses/30/lessons/131705)

```jsx
function solution(arr) {
  let count = 0;
  const len = arr.length;
  
  for (let i = 2; i < len; i++) {
    for (let j = i; j < len; j++) {
      for (let k = j; k < len; k++) {
        if (arr[i - 2] + arr[j - 1] + arr[k] === 0) count++;
      }
    }
  }
  return count;
}
```

순열과 조합이 생각났지만, 구현할 줄 몰라서

역시 예제를 대입해보면서 규칙을 찾고, 그대로 구현

## 7. [최소직사각형](https://school.programmers.co.kr/learn/courses/30/lessons/86491)

```jsx
function solution(sizes) {
  let maxW = 0;
  let maxH = 0;

  for (let i = 0; i < sizes.length; i++) {
    const [w, h] = sizes[i];

    // 가로, 세로 둘다 작으면 통과
    if (w <= maxW && h <= maxH) {
      continue;
    // 가로, 세로 둘다 크면, 무조건 바꾸기
    } else if (w > maxW && h > maxH) {
      maxW = w;
      maxH = h;
      continue;
    } else { // 중요한건 가로의 증가량이 큰가, 세로의 증가량이 큰가를 비교하는것
      const plus_a_w = w - maxW > 0 ? w - maxW : 0;
      const plus_a_h = h - maxH > 0 ? h - maxH : 0;
      const plus_b_w = w - maxH > 0 ? w - maxH : 0;
      const plus_b_h = h - maxW > 0 ? h - maxW : 0;

      if (plus_a_w + plus_a_h < plus_b_w + plus_b_h) {
        maxW = Math.max(maxW, w);
        maxH = Math.max(maxH, h);
      } else {
        maxW = Math.max(maxW, h);
        maxH = Math.max(maxH, w);
      }
    }
  }

  return maxW * maxH;
}
```

이렇게 했지만, 다른사람 풀이의 이렇게가 더 보기 편하다.

정렬을 하면, 비교가 간편해진다는 사실을 왜 몰랐을까?

되게 좋은 접근인거 같다. 다음에 활용해봐야지

```jsx
function solution(sizes) {
    const rotated = sizes.map(([w, h]) => w < h ? [h, w] : [w, h]);

    let maxSize = [0, 0];
    rotated.forEach(([w, h]) => {
        if (w > maxSize[0]) maxSize[0] = w;
        if (h > maxSize[1]) maxSize[1] = h;
    })
    return maxSize[0]*maxSize[1];
}
```

## 8. [시저 암호](https://school.programmers.co.kr/learn/courses/30/lessons/12926)

```jsx
function solution(s, n) {
  return s
    .split("")
    .map((a) => getNewStr(a, n))
    .join("");
}

const getNewStr = (a, n) => {
  const step = n % 26;
  if (a === " ") return " ";

  const ascii = a.charCodeAt(0);

  const isUpper = ascii >= 65 && ascii <= 90;

  const sum = ascii + step;
  const nextN = isUpper ? sum > 90 ? 65 + (sum - 91) : sum
                        : sum > 122 ? 97 + (sum - 123) : sum;

  return String.fromCharCode(nextN);
};
```

## 9. [가장 가까운 같은 글자](https://school.programmers.co.kr/learn/courses/30/lessons/142086)

```jsx
function solution(s) {
  const m = new Map(); // key: alphabet, value: last index
  return s.split("").map((a, i) => {
    if (!m.has(a)) {
      m.set(a, i);
      return -1;
    }
    const result = i - m.get(a);
    m.set(a, i);
    return result;
  });
}

```

그냥 구현

## 10. [숫자 문자열과 영단어](https://school.programmers.co.kr/learn/courses/30/lessons/81301)

```jsx
function solution(s) {
  var answer = "";
  // 문자열을 조회하면서
  // 해당 인덱스가 숫자인지 문자인주 구분을 한다.
  // 숫자면 그대로 더하고
  // 문자면 문자 배열에서 동일한 문자와 매핑한 숫자를 더하는데,

  // 1. 문자인지 숫자인지 구분한다 => ascii코드 값을 이용한다.

  // 2. 해당 문자가 어디까지 어떤 문자인지 구분한다. => 최소 3자리니까 해당 것 까지 비교해서 알아낸다.
  // 객체에 key는 문자, value는 숫자를 넣는다.
  // 그래서 해당 key를 찾고, 그 key의 length까지 인덱스를 넘긴다.
  let StringObject = {
    zero: 0,
    one: 1,
    two: 2,
    three: 3,
    four: 4,
    five: 5,
    six: 6,
    seven: 7,
    eight: 8,
    nine: 9,
  };

  for (let i = 0; i < s.length; i++) {
    let ascii = s[i].charCodeAt();
    if (ascii > 47 && ascii < 58) {
      answer += s[i];
    } else {
      let threeS = s[i] + s[i + 1] + s[i + 2];
      for (let j in StringObject) {
        if (j.includes(threeS)) {
          answer += StringObject[j];
          i += j.length - 1;
        }
      }
    }
  }
  return answer * 1;
}

```

예전에 푼거 다시 안풀었는데, 다시 풀어보아야할지도..?

## 11. [K번째수](https://school.programmers.co.kr/learn/courses/30/lessons/42748)

```jsx
function solution(array, commands) {
  var answer = [];
  for (let command of commands) {
    let a = array.slice(command[0] - 1, command[1]);
    a.sort((a, b) => a - b);
    answer.push(a[command[2] - 1]);
  }
  return answer;
}
```

그냥 구현

## 12. [두 개 뽑아서 더하기](https://school.programmers.co.kr/learn/courses/30/lessons/68644)

```jsx
function solution(numbers) {
  var answer = [];

  for (let i = 0; i < numbers.length - 1; i++) {
    for (let j = i + 1; j < numbers.length; j++) {
      let va = numbers[i] + numbers[j];
      if (!answer.includes(va)) answer.push(va);
    }
  }

  return answer.sort((a, b) => a - b);
}
// prev

```

그냥 구현

## 13. [푸드 파이트 대회](https://school.programmers.co.kr/learn/courses/30/lessons/134240)

```jsx
function solution(food) {
  const arr = food.slice(1).map((f) => Math.floor(f / 2));
  const front = [];
  const back = [];
  for (let i = 0; i < arr.length; i++) {
    const s = `${i + 1}`.repeat(arr[i]);
    front.push(s);
    back.unshift(s);
  }
  return front.join("") + "0" + back.join("");
}
```

```jsx
 * 문제가 긴것 치곤 간단했다.
 * 별다른 트릭도 없었고 시간복잡도를 고려할 필요는 없었다.
 * 다만 unshift, repeat를 잘 알았어야 했다.
```

## 14. [문자열 내 마음대로 정렬하기](https://school.programmers.co.kr/learn/courses/30/lessons/12915)

```jsx
function solution(strings, n) {
  return strings.sort((a, b) => {
    if (a[n] === b[n]) {
      let i = 0;
      let result = 0;
      while (true) {
        // 앞에서 부터 비교해서 하나라도 다른게 나오면 끝
        // 끝이면 앞이 작으면 -1을 아니면 1을 리턴
        if (a[i].charCodeAt(0) !== b[i].charCodeAt(0)) {
          result = a[i].charCodeAt(0) - b[i].charCodeAt(0);
          break;
        }
        i++;
      }
      return result;
    }
    return a[n].charCodeAt(0) - b[n].charCodeAt(0);
  });
}

```

기억이 나지 않음

## 15. [콜라 문제](https://school.programmers.co.kr/learn/courses/30/lessons/132267)

```jsx
function solution(a, b, n) {
  let count = 0;
  while (n >= a) {
    const curCount = Math.floor(n / a) * b;
    count += Math.floor(n / a) * b;
    n = curCount + (n % a);
  }
  return count;
}

```

그냥 복잡하지 않은 구현이라 예문 도입하면서 풀면 끝

## 16. [[1차] 비밀지도](https://school.programmers.co.kr/learn/courses/30/lessons/17681)

```jsx
function solution(n, arr1, arr2) {
  var answer = [];

  let b_arr1 = toBinary(arr1, n);
  let b_arr2 = toBinary(arr2, n);

  for (let i = 0; i < n; i++) {
    let line = ""
    for (let j = 0; j < n; j++) {
      if (b_arr1[i][j] === '0' && b_arr2[i][j] === '0') {
        line += " "
      } else {
        line += "#"
      }
    }
    answer.push(line)
  }

  return answer;
}

function toBinary(arr, n) {
  let b_arr = []
  for (let i = 0; i < arr.length; i++) {
    if (arr[i].toString(2).length < n) {
      let plus_z = n - arr[i].toString(2).length;
      let p_z = ""
      for (let j = 0; j < plus_z; j++) {
        p_z += "0"
      }
      b_arr[i] = p_z + arr[i].toString(2);
    } else {
      b_arr[i] = arr[i].toString(2)
    }
  }
  return b_arr;
}
```

이전에 풀었던거라 넘어갔는데 다시 풀어봐야할 듯

## 17. [명예의 전당 (1)](https://school.programmers.co.kr/learn/courses/30/lessons/138477)

```jsx
function solution(k, score) {
  let min = 2000;
  const answer = [];
  const list = [];

  for (let i = 0; i < score.length; i++) {
    const element = score[i];
    if (i < k) {
      list.push(element);

      min = Math.min(min, element);
      answer.push(min);
      continue;
    }

    list.push(element);
    list.sort((a, b) => a - b);
    list.shift();

    answer.push(list[0]);
  }
  return answer;
}
```

개선할 점이 많이 보이는것 같긴한데..

## 18. [추억 점수](https://school.programmers.co.kr/learn/courses/30/lessons/176963)

```jsx
function solution(name, yearning, photo) {
  const m = new Map();

  name.forEach((n, i) => {
    m.set(n, yearning[i]);
  });

  return photo.reduce((acc, cur) => {
    const sum = cur.reduce((a, c) => a + (m.get(c) ?? 0), 0);
    return [...acc, sum];
  }, []);
}

```

## 19. [카드 뭉치](https://school.programmers.co.kr/learn/courses/30/lessons/159994)

```jsx
function solution(cards1, cards2, goal) {
  return recursion(cards1, cards2, goal) ? "Yes" : "No";
}

const recursion = (c1, c2, g) => {
  if (g.length === 0) return true;

  if (c1[0] !== g[0] && c2[0] !== g[0]) return false;

  if (c1[0] === g[0]) return recursion(c1.slice(1), c2, g.slice(1));
  if (c2[0] === g[0]) return recursion(c1, c2.slice(1), g.slice(1));
};

```

## 20. [폰켓몬](https://school.programmers.co.kr/learn/courses/30/lessons/1845)

```jsx
function solution(nums) {
  var answer = 0;
  let halfLength = nums.length / 2;
  let setNums = new Set(nums);
  if (setNums.size >= halfLength) {
    answer = halfLength;
  } else {
    answer = setNums.size;
  }

  return answer;
}
//prev

```

## 21. [2016년](https://school.programmers.co.kr/learn/courses/30/lessons/12901)

```jsx
function solution(a, b) {
  const cal = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  const day = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"];
  const count =
    cal.reduce((acc, cur, i) => {
      if (i + 1 >= a) return acc;
      return acc + cur;
    }, 0) + b;

  const index = (count + 5) % 7 === 0 ? 7 : (count + 5) % 7;
  return day[index - 1];
}

// 뭔가 나누어 떨어지는 경우 뒤에 -1말고 앞에서 -1하고 싶은데 가능하려나 그게
```

단순 구현해봄, Date 객체만 안쓰면 되지 않을까 싶음

## 22. [기사단원의 무기](https://school.programmers.co.kr/learn/courses/30/lessons/136798)

```jsx
function solution(number, limit, power) {
  let answer = 0;
  for (let i = 1; i <= number; i++) {
    const count = getCount(i);
    if (count > limit) {
      answer += power;
    } else {
      answer += count;
    }
  }
  return answer;
}

const getCount = (n) => {
  if (n === 1) return 1;
  if (n === 2 || n === 3) return 2;

  let count = 0;
  let hasSqrt = 0;

  for (let i = 0; i <= Math.sqrt(n); i++) {
    if (n % i === 0) {
      if (i === Math.sqrt(n)) {
        hasSqrt = 1;
      } else {
        count++;
      }
    }
  }
  return count * 2 + hasSqrt;
};
```

생각보다 시간이 걸림

일단 말대로 구현해서 해결한것 같음..

## 23. https://school.programmers.co.kr/learn/courses/30/lessons/42840

```jsx
function solution(answers) {
  var answer = [];
  let a1 = [1, 2, 3, 4, 5];
  let a2 = [2, 1, 2, 3, 2, 4, 2, 5];
  let a3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5];

  // 정답자를 배열에 담고
  let a_arr = [0, 0, 0];
  for (let i in answers) {
    if (answers[i] === a1[i % a1.length]) a_arr[0]++;
    if (answers[i] === a2[i % a2.length]) a_arr[1]++;
    if (answers[i] === a3[i % a3.length]) a_arr[2]++;
  }
  
  // 최고값을 가져내서
  let _max = Math.max(...a_arr);

  // 최고값과 비교했을 때 맞으면 해당 index+1을 answer배열에 push
  for (let i = 0; i < a_arr.length; i++) {
    if (_max === a_arr[i]) answer.push(i + 1);
  }
  return answer;
}
// prev
```

## 24. [과일 장수](https://school.programmers.co.kr/learn/courses/30/lessons/135808)

```jsx
function solution(k, m, score) {
  return score
    .sort((a, b) => a - b)
    .slice(score.length % m)
    .reduce((acc, cur, i) => {
      if (i % m === 0) {
        return acc + cur * m;
      }
      return acc;
    }, 0);
}
```

## 25. [소수 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/12977)

```jsx
function solution(nums) {
  let answer = 0;
  const len = nums.length;

  for (let i = 0; i < len; i++) {
    for (let j = i + 1; j < len; j++) {
      for (let k = j + 1; k < len; k++) {
        if (isPrime(nums[i] + nums[j] + nums[k])) {
          answer++;
        }
      }
    }
  }

  return answer;
}

const isPrime = (n) => {
  for (let i = 2; i <= Math.sqrt(n); i++) {
    if (n % i === 0) return false;
  }
  return true;
};

```

isPrime은 이전에 했었고

순열?도 이전에 했어서 쉬웠다.